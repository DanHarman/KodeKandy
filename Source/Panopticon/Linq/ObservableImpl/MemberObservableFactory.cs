// <copyright file="MemberObservableFactory.cs" company="million miles per hour ltd">
// Copyright (c) 2013-2014 All Right Reserved
// 
// This source is subject to the MIT License.
// Please see the License.txt file for more information.
// All other rights reserved.
// 
// THIS CODE AND INFORMATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY 
// KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
// </copyright>

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using KodeKandy.Panopticon.Properties;

namespace KodeKandy.Panopticon.Linq.ObservableImpl
{
    /// <summary>
    ///     Factory class to create member observables that supports multi node paths to child members.
    ///     It caches delegate to minimise the use of reflection to once per type. Reflection is required to avoid unnecessary
    ///     boxing of value types.
    /// </summary>
    internal static class MemberObservableFactory
    {
        private static readonly MethodInfo _createNotifyPropertyChangedValueObservable =
            typeof(MemberObservableFactory).GetMethod("CreateNotifyPropertyChangedValueObservable",
                BindingFlags.Static | BindingFlags.NonPublic);

        private static readonly MethodInfo _createPocoObservable =
            typeof(MemberObservableFactory).GetMethod("CreatePocoObservable",
                BindingFlags.Static | BindingFlags.NonPublic);

        private static readonly MethodInfo _createNotifyPropertyChangedObservable =
            typeof(MemberObservableFactory).GetMethod("CreateNotifyPropertyChangedObservable",
                BindingFlags.Static | BindingFlags.NonPublic);

        private static readonly Dictionary<MemberInfo, Delegate> _observableValueDelegateCache = new Dictionary<MemberInfo, Delegate>();
        private static readonly Dictionary<Type, Delegate> _observablePropertyChangedDelegateCache = new Dictionary<Type, Delegate>();
        private static readonly object _gate = new object();

        /// <summary>
        ///     Creates an <see cref="IObservable{TMember}" /> for the supplied memberPath. The observable works across changes to
        ///     nodes in the chain.
        /// </summary>
        /// <typeparam name="TClass">The type of the root class being observed.</typeparam>
        /// <typeparam name="TMember">The type of the final member</typeparam>
        /// <param name="source">The source instance.</param>
        /// <param name="memberPath">The path to the final member.</param>
        /// <returns>An <see cref="IObservable{TMember}" /></returns>
        public static IObservable<PropertyValueChanged<TMember>> CreateValueObserver<TClass, TMember>(TClass source, Expression<Func<TClass, TMember>> memberPath)
        {
            var memberInfos = ExpressionHelpers.GetMemberInfos(memberPath);

            object currObserver = source.ToPropertyValueChanged().Forever();
            foreach (var memberInfo in memberInfos)
            {
                var create = (Func<object, MemberInfo, object>) CreateObservableMemberValueChangedDelegate(memberInfo);
                currObserver = create(currObserver, memberInfo);
            }

            return (IObservable<PropertyValueChanged<TMember>>) currObserver;
        }

        /// <summary>
        ///     Creates an <see cref="IObservable{PropertyChanged}" /> for the supplied memberPath. The final nodes must implement
        ///     <see cref="INotifyPropertyChanged" />. The observable works across changes to nodes in the chain.
        /// </summary>
        /// <typeparam name="TClass">The type of the root class being observed.</typeparam>
        /// <typeparam name="TProperty">
        ///     The type of the final property which will supply the stream of <see cref="PropertyChanged" />.
        /// </typeparam>
        /// <param name="source">THe source instance.</param>
        /// <param name="memberPath">The path to the final member.</param>
        /// <returns>An <see cref="IObservable{PropertyChanged}" /> generated by PropertyChanges on the final node.</returns>
        public static IObservable<PropertyChanged> CreatePropertyChangedObserver<TClass, TProperty>(TClass source,
            Expression<Func<TClass, TProperty>> memberPath)
            where TProperty : INotifyPropertyChanged
        {
            var memberInfos = ExpressionHelpers.GetMemberInfos(memberPath).ToList();

            object currObserver = source.Forever();

            var cnt = 0;
            foreach (var memberInfo in memberInfos)
            {
                ++cnt;

                var create = (Func<object, MemberInfo, object>) CreateObservableMemberValueChangedDelegate(memberInfo);
                currObserver = create(currObserver, memberInfo);

                // For the final member we don't just want its value, we want to Observe its property changes.             
                if (cnt == memberInfos.Count)
                {
                    var createFinal = (Func<object, object>) CreateObservablePropertyChangedDelegate(memberInfo.GetMemberType());
                    currObserver = createFinal(currObserver);
                }
            }

            return (IObservable<PropertyChanged>) currObserver;
        }

        private static Delegate CreateObservableMemberValueChangedDelegate(MemberInfo memberInfo)
        {
            Delegate result;

            lock (_gate)
            {
                // See if its in the cache?
                if (_observableValueDelegateCache.TryGetValue(memberInfo, out result))
                    return result;

                var instanceType = memberInfo.ReflectedType;
                var memberType = memberInfo.GetMemberType();

                MethodInfo specialisedMethod;

                // Create the appropriate Link type.
                if (typeof(INotifyPropertyChanged).IsAssignableFrom(instanceType))
                    specialisedMethod = _createNotifyPropertyChangedValueObservable.MakeGenericMethod(instanceType, memberType);
                else
                    specialisedMethod = _createPocoObservable.MakeGenericMethod(instanceType, memberType);

                result = Delegate.CreateDelegate(typeof(Func<,,>).MakeGenericType(typeof(object), typeof(MemberInfo), typeof(object)),
                    specialisedMethod);

                _observableValueDelegateCache.Add(memberInfo, result);
            }

            return result;
        }

        private static Delegate CreateObservablePropertyChangedDelegate(Type classType)
        {
            Delegate result;

            lock (_gate)
            {
                if (_observablePropertyChangedDelegateCache.TryGetValue(classType, out result))
                    return result;

                MethodInfo specialisedMethod = _createNotifyPropertyChangedObservable.MakeGenericMethod(classType);

                result = Delegate.CreateDelegate(typeof(Func<,>).MakeGenericType(typeof(object), typeof(object)),
                    specialisedMethod);

                _observablePropertyChangedDelegateCache.Add(classType, result);
            }

            return result;
        }

        [UsedImplicitly]
        private static object CreateNotifyPropertyChangedValueObservable<TClass, TMember>(object source, MemberInfo memberInfo)
            where TClass : class, INotifyPropertyChanged
        {
            var getter = ReflectionHelpers.CreateMemberGetter(memberInfo);

            return new NotifyPropertyValueChangedObservable<TClass, TMember>((IObservable<PropertyValueChanged<TClass>>) source, memberInfo.Name,
                (Func<TClass, TMember>) getter);
        }

        [UsedImplicitly]
        private static object CreatePocoObservable<TClass, TMember>(object source, MemberInfo memberInfo)
            where TClass : class
        {
            var getter = ReflectionHelpers.CreateMemberGetter(memberInfo);

            return new PocoValueObservable<TClass, TMember>((IObservable<PropertyValueChanged<TClass>>) source, memberInfo.Name, (Func<TClass, TMember>) getter);
        }

        [UsedImplicitly]
        private static object CreateNotifyPropertyChangedObservable<TClass>(object source)
            where TClass : class, INotifyPropertyChanged
        {
            return new NotifyPropertyChangedObservable<TClass>((IObservable<TClass>) source);
        }
    }
}